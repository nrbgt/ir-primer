doctype html
html(lang="en")
  head
    meta(charset="utf-8")

    style: :stylus
      @import "./bower_components/d3.slider/d3.slider.css"

      axis-font = 11px

      body
        overflow hidden
        margin 0
        padding 0
        font-family "Gill Sans MT", "Gill Sans"

      h1
        margin 0
        padding 0

      header
        padding 20px 80px 20px 80px

      .title
        text-align center
        position absolute
        right 50px
        top 120px

        blockquote
          width 190px
          font-family serif


      .slider-wrap
        .slider
          width 100%
          margin-top 30px

          .handle-label
            font-size 14px
            font-weight bold
            text-align center
            margin-top -20px
            margin-left -20px
            display block

      svg
        .label
          font-size 32px

          .unit
            fill #777

        .axis
          line, path
            fill none
            stroke black
            shape-rendering crispEdges
          text
            font-size axis-font
            text-anchor middle

        .plots
          path
            fill none
            stroke-width 2px
          .interactive
            path
              stroke black !important
              stroke-width 4px

    script(type="text/x-mathjax-config")
      :coffee
        MathJax.Hub.Config {
          tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
        }
    script(
      src="./bower_components/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML")


  body
    header
      .slider-wrap
        .slider
    .title
      h1 Planck's Law
      .equation
        blockquote
          :markdown
            The EM modes exist with only discrete energies that are multiples
            of _hv_, where _h_ is Planck's constant and _v_ is frequency.
        span.
          $$
          I(\lambda,T) =
          \frac{2 hc^2}{\lambda^5}\frac{1}{ e^{\frac{hc}{\lambda kT}}-1}
          $$

    .plot.planck

    script(src="./bower_components/d3/d3.min.js")
    script(src="./bower_components/d3.slider/d3.slider.js")
    script
      :coffee
        # screen-dependent globals
        w = h = el_givens = temperature = null

        # magic numbers
        padding = top: 10, left: 80, right: 80, bottom: 80
        xDomain = [0.1, 100]
        yDomain = [1e-4, 1e9]
        axisW = 20

        # constants
        c1_boltzman = 3.74e8
        c2_boltzman = 1.44e4
        wien = 2898

        # formulae
        plancks_law = (temperature, wavelength)->
          [
            wavelength,
            c1_boltzman / (
              (wavelength ** 5) * (
                Math.exp(c2_boltzman / (wavelength * temperature)) - 1
              )
            )
          ]

        header = d3.select("header").node()

        # data
        wavelengths = [
          0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9,
          1, 1.5, 2, 2.5, 3, 4, 5, 6, 7, 8, 9, 10, 11,
          12, 20, 30, 40, 50, 60, 70, 80, 90, 100
        ]

        temperatures = [
          100, 200, 400, 600, 800, 1000,
          2000, 3000, 4000, 5000, 6000
        ]

        # d3 generatory things
        expwn = (d) ->
          d.toExponential 1
            .replace /^(.*)e([+-])(\d*)$/,
              (match, mag, sign, exp)->
                sign = if sign == "-" then "⁻" else ""
                exp =  exp.split ""
                  .map (e) -> "⁰¹²³⁴⁵⁶⁷⁸⁹"[+e]
                  .join ""
                mag + "×10" + sign + exp

        makeSeries = (temperature)->
          temperature: temperature
          spectral_exitance: wavelengths
            .map (wavelength)-> plancks_law temperature, wavelength
            .filter (point)-> point[1]

        color = d3.scale.category20c()

        seriesPath = d3.svg.line()
          .x (d) -> xScale d[0]
          .y (d) -> yScale d[1]
          .interpolate "basis"

        plotSeries = (series) ->
          series
            .call (series) ->
              series.enter()
                .append "g"
                .classed series: true
                .append "path"
            .selectAll "path"
              .data (d) -> [d.spectral_exitance]
              .attr d: seriesPath
              .style stroke: color

        givens = temperatures.map makeSeries

        # Slider stuff
        sliderAxis = d3.svg.axis()
          .orient "bottom"
          .ticks 5
          .tickFormat expwn

        slider = d3.slider()
          .axis sliderAxis
          .min temperatures[0]
          .max temperatures.slice(-1)[0]
          .on "slide", (evt, value) ->
            handle_label.text "T=#{  expwn(value) }K"
            temperature = value
            render()

        el_slider = d3.select ".slider"
          .call slider

        handle_label = el_slider.select ".d3-slider-handle"
          .append "span"
          .classed "handle-label": true

        xScale = d3.scale.log().domain xDomain
        yScale = d3.scale.log().domain yDomain

        xAxis = d3.svg.axis()
          .scale xScale
          .orient 'bottom'

        yAxis = d3.svg.axis()
          .scale yScale
          .orient 'left'

        svg = d3.select ".plot.planck"
          .append "svg"

        defs = svg.append "defs"

        clip = defs.append "clipPath"
          .attr id: "planckPath"
          .append "rect"

        el_xAxis = svg.append 'g'
          .classed axis: true

        el_yAxis = svg.append 'g'
          .classed axis: true
          
        yLabel = svg.append "g"
          .classed label: true, x: true
          .append "text"
          .attr "text-anchor": "middle", dy: ".71em"
          .call (yLabel) ->
            yLabel.append "tspan"
              .text "Spectral Exitance"

            yLabel.append "tspan"
              .classed unit: true
              .text " W/m²-µ"

        xLabel = svg.append "g"
          .classed label: true, y: true
          .append "text"
          .attr "text-anchor": "middle", dy: ".71em"
          .call (yLabel) ->
            yLabel.append "tspan"
              .text "Wavelength"

            yLabel.append "tspan"
              .classed unit: true
              .text " µ"

        plots = svg.append "g"
          .classed plots: 1
          .attr "clip-path": "url(#planckPath)"

        render = ->
          series = makeSeries temperature
          plots.selectAll '.interactive'
            .data [series]
            .call plotSeries
            .classed interactive: true
            .select "path"
              .style color: "black"
        
        # update screen-relevant stuff
        init = ->
          w = window.innerWidth
          h = window.innerHeight - header.clientHeight + 20
          xScale.range [padding.left, w - padding.right]
          yScale.range [h - padding.bottom, padding.top]
          svg.attr width: w, height: h
          clip.attr {
            width: xScale.range()[1]
            height: yScale.range()[0]
          }
          el_xAxis.attr transform: "translate(#{[ 0, h - padding.bottom ] })"
            .call xAxis
          el_yAxis.attr transform: "translate(#{ [padding.left, 0] })"
            .call yAxis
          yLabel.attr transform: "translate(10, #{ h/2 }) rotate(-90)"
          xLabel.attr transform: "translate(#{ [w/2, h - 50] })"
          el_givens = plots.selectAll '.series'
            .data givens
            .call plotSeries
          console.log( el_slider.select "svg > g"
            .call sliderAxis)
          render()
        init()

        d3.select(window).on resize: init
