// Generated by CoffeeScript 1.9.0
(function() {
  define(["./explanation.js"], function(Exp) {
    var Density, d3, domains, elevations, i, padding, references, solutionParts;
    d3 = null;
    padding = {
      top: 40,
      left: 120,
      right: 120,
      bottom: 110
    };
    domains = {
      x: [0, 2.5e4],
      y: [[0, 300], [0, 1]]
    };
    elevations = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; _i <= 2.5e4; i = _i += 500) {
        _results.push(i);
      }
      return _results;
    })();
    solutionParts = ["K", "rP", "rD"];
    references = solutionParts.map(function(key, i) {
      return {
        series: key,
        scaleIdx: i === 2 ? 1 : i,
        points: []
      };
    });
    elevations.map(function(elevation) {
      var data;
      data = Exp.laws.Density(elevation);
      return references.map(function(series) {
        return series.points.push([elevation, data[series.series]]);
      });
    });
    Density = function(_d3) {
      var api, axes, plotSeries, scales, seriesPath;
      d3 = _d3;
      scales = {
        x: d3.scale.linear().domain(domains.x),
        y: [d3.scale.linear().domain(domains.y[0]), d3.scale.linear().domain(domains.y[1])],
        color: d3.scale.ordinal().range(["blue", "red", "green"])
      };
      axes = {
        x: d3.svg.axis().scale(scales.x).orient('bottom'),
        y: [d3.svg.axis().scale(scales.y[0]).orient('left'), d3.svg.axis().scale(scales.y[1]).orient('right')]
      };
      seriesPath = function(y) {
        return d3.svg.line().x(function(d) {
          return scales.x(d[0]);
        }).y(function(d) {
          return y(d[1]);
        });
      };
      plotSeries = function(series) {
        return series.call(function(series) {
          return series.enter().append("g").classed({
            series: true
          }).append("path").style({
            stroke: function(d, i) {
              return scales.color(i);
            }
          });
        }).selectAll("path").attr({
          d: function(d, i) {
            var fn;
            fn = seriesPath(scales.y[d.scaleIdx]);
            return fn(d.points);
          }
        });
      };
      api = function(selection) {
        var ELEVATION, clip, defs, el_xAxis, el_y0Axis, el_y1Axis, plots, plotsBg, solutions, svg, xLabel, y0Label, y1Label;
        selection.classed({
          density: true,
          explanation: true
        });
        ELEVATION = 60;
        api.explore = function() {
          var mouseX, mouseY, _ref;
          _ref = d3.mouse(this), mouseX = _ref[0], mouseY = _ref[1];
          ELEVATION = Math.min(domains.x[1], Math.max(scales.x.invert(mouseX), domains.x[0]));
          return api.update();
        };
        api.update = function() {
          var scaleSolution, scaleSolutions;
          scaleSolution = Exp.laws.Density(ELEVATION);
          scaleSolutions = solutionParts.map(function(part) {
            return [ELEVATION, scaleSolution[part]];
          });
          svg.selectAll(".solution.interactive").data([[ELEVATION, ELEVATION], [ELEVATION, scaleSolutions[0][1]], [ELEVATION, scaleSolutions[1][1]], [ELEVATION, scaleSolutions[2][1]]]).call(function(solutionLabel) {
            return solutionLabel.enter().append("g").classed({
              solution: true,
              interactive: true
            }).append("text").style({
              fill: function(d, i) {
                return ["black", "blue", "red", "green"][i];
              }
            }).attr({
              "text-anchor": function(d, i) {
                if (i === 0) {
                  return "middle";
                } else if (i === 1) {
                  return "start";
                } else {
                  return "end";
                }
              }
            });
          }).attr({
            transform: function(d, i) {
              if (i === 0) {
                return "translate(" + (scales.x(d[1])) + ", " + (padding.top - 10) + ")";
              } else if (i === 1) {
                return "translate(" + (padding.left + 5) + ", " + (scales.y[0](d[1])) + ")";
              } else {
                return "translate(" + (scales.x.range()[1] - 5) + ", " + (scales.y[1](d[1])) + ")";
              }
            }
          }).select("text").text(function(d, i) {
            return ['m', 'K', 'rP', 'rD'][i] + " = " + (d[1].toFixed(2));
          });
          solutions.selectAll(".solution.reference").data(scaleSolutions).call(function(solution) {
            return solution.enter().append("g").classed({
              solution: true,
              reference: true
            }).call(function(solution) {
              return solution.append("circle").attr({
                r: 5
              }).style({
                stroke: function(d, i) {
                  return scales.color(i);
                }
              });
            });
          }).attr({
            transform: function(d, i) {
              i = i === 0 ? 0 : 1;
              return "translate(" + (scales.x(d[0])) + ", " + (scales.y[i](d[1])) + " )";
            }
          });
          return api;
        };
        api.resize = function(event) {
          var HEIGHT, WIDTH;
          WIDTH = selection.node().clientWidth;
          HEIGHT = selection.node().clientHeight;
          scales.x.range([padding.left, WIDTH - padding.right]);
          scales.y.map(function(scale) {
            return scale.range([HEIGHT - padding.bottom, padding.top]);
          });
          svg.attr({
            width: WIDTH,
            height: HEIGHT
          });
          plotsBg.attr({
            y: padding.top,
            width: WIDTH - padding.right,
            height: HEIGHT - padding.top
          });
          plots.selectAll('.series').data(references).call(plotSeries);
          clip.attr({
            width: WIDTH,
            height: scales.y[0].range()[0],
            y: padding.top,
            x: 0
          });
          el_xAxis.attr({
            transform: "translate(0, " + (HEIGHT - padding.bottom) + ")"
          }).call(axes.x);
          el_y0Axis.attr({
            transform: "translate(" + padding.left + ", 0)"
          }).call(axes.y[0]);
          el_y1Axis.attr({
            transform: "translate(" + (WIDTH - padding.right) + ", 0)"
          }).call(axes.y[1]);
          xLabel.attr({
            transform: "translate(" + (WIDTH / 2) + ", " + (scales.y[0].range()[0] + 40) + ")"
          });
          y0Label.attr({
            transform: "translate(10, " + (HEIGHT / 2) + ") rotate(-90)"
          });
          y1Label.attr({
            transform: "translate(" + (WIDTH - 10) + ", " + (HEIGHT / 2) + ") rotate(90)"
          });
          return api.update();
        };
        svg = selection.selectAll(".plot").data([1]).call(function(svg) {
          svg = svg.enter().append("svg").classed({
            plot: true
          });
          svg.append("defs").append("clipPath").classed({
            "density-path": true
          }).attr({
            id: "densityPath"
          }).append("rect");
          svg.append("g").classed({
            plots: true
          }).attr({
            "clip-path": "url(#densityPath)"
          }).call(function(plots) {
            plots.append("rect").classed({
              bg: true
            }).on({
              mousemove: api.explore
            });
            return plots.append("g").classed({
              solutions: true
            });
          });
          svg.append("g").classed({
            axis: true,
            x: true
          });
          svg.append("g").classed({
            axis: true,
            y0: true
          });
          svg.append("g").classed({
            axis: true,
            y1: true
          });
          svg.append("g").classed({
            label: true,
            x: true
          }).append("text").attr({
            "text-anchor": "middle",
            dy: ".71em",
            y: -10
          }).call(function(xLabel) {
            xLabel.append("tspan").text("Altitude");
            return xLabel.append("tspan").classed({
              unit: true
            }).text(" [m]");
          });
          svg.append("g").classed({
            label: true,
            y0: true
          }).append("text").attr({
            "text-anchor": "middle",
            dy: ".71em"
          }).call(function(yLabel) {
            yLabel.append("tspan").text("Temperature ");
            return yLabel.append("tspan").classed({
              unit: true
            }).text("[K]");
          });
          return svg.append("g").classed({
            label: true,
            y1: true
          }).append("text").attr({
            "text-anchor": "middle",
            dy: ".71em",
            y: -10
          }).call(function(yLabel) {
            yLabel.append("tspan").text("Relative Pressure, Density ");
            return yLabel.append("tspan").classed({
              unit: true
            }).text("[bar, rho]");
          });
        });
        plots = svg.select(".plots");
        solutions = plots.select(".solutions");
        plotsBg = plots.select(".bg");
        defs = svg.select("defs");
        clip = defs.select(".density-path rect");
        el_xAxis = svg.select(".axis.x");
        el_y0Axis = svg.select(".axis.y0");
        el_y1Axis = svg.select(".axis.y1");
        xLabel = svg.select(".label.x text");
        y0Label = svg.select(".label.y0 text");
        y1Label = svg.select(".label.y1 text");
        d3.select(window).on({
          "resize.density": api.resize
        });
        return api.resize();
      };
      return api;
    };
    return Density;
  });

}).call(this);
