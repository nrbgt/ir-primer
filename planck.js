// Generated by CoffeeScript 1.9.0
(function() {
  define([], function() {
    var Planck, axisW, c1_boltzman, c2_boltzman, c_wien, d3, expwn, i, makeSeries, padding, plancksLaw, sidebarWidth, sliderCircle, sliderPadding, temperatures, wavelengths, wiens, wiensLaw, xDomain, yDomain;
    d3 = null;
    c1_boltzman = 3.74e8;
    c2_boltzman = 1.44e4;
    c_wien = 2898;
    plancksLaw = function(temperature, wavelength) {
      return [wavelength, c1_boltzman / ((Math.pow(wavelength, 5)) * (Math.exp(c2_boltzman / (wavelength * temperature)) - 1))];
    };
    wiensLaw = function(temperature) {
      return plancksLaw(temperature, c_wien / temperature);
    };
    padding = {
      top: 40,
      left: 120,
      right: 80,
      bottom: 90
    };
    sliderPadding = {
      top: 80,
      left: 10,
      right: 10,
      bottom: 110,
      temperature: 40,
      solution: 140
    };
    xDomain = [0.1, 100];
    yDomain = [1e-4, 1e9];
    axisW = 20;
    sliderCircle = {
      r: 5,
      cx: 0
    };
    sidebarWidth = 180;
    wavelengths = ((function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0.1; _i <= 1.99; i = _i += 0.01) {
        _results.push(i);
      }
      return _results;
    })()).concat((function() {
      var _i, _results;
      _results = [];
      for (i = _i = 2; _i <= 19.5; i = _i += 0.5) {
        _results.push(i);
      }
      return _results;
    })()).concat((function() {
      var _i, _results;
      _results = [];
      for (i = _i = 20; _i <= 100; i = _i += 1) {
        _results.push(i);
      }
      return _results;
    })());
    temperatures = [100, 200, 400, 600, 800, 1000, 2000, 3000, 4000, 5000, 6000];
    wiens = temperatures.map(function(temperature) {
      return wiensLaw(temperature);
    });
    expwn = function(d) {
      if (!d) {
        return;
      }
      return parseFloat(d).toExponential(1).replace(/^(.*)e([+-])(\d*)$/, function(match, mag, sign, exp) {
        mag = mag === "1.0" ? "" : mag.replace(/\.0$/, "") + "×";
        sign = sign === "-" ? "⁻" : "";
        exp = exp.split("").map(function(e) {
          return "⁰¹²³⁴⁵⁶⁷⁸⁹"[+e];
        }).join("");
        return mag + "10" + sign + exp;
      });
    };
    makeSeries = function(temperature) {
      return {
        temperature: temperature,
        spectral_exitance: wavelengths.map(function(wavelength) {
          return plancksLaw(temperature, wavelength);
        }).filter(function(point) {
          return point[1];
        })
      };
    };
    Planck = function(_d3) {
      var HOVERWIEN, TEMPERATURE, WAVELENGTH, api, color, plotSeries, references, seriesPath, sliderScale, temperatureColor, xAxis, xScale, yAxis, yScale;
      d3 = _d3;
      TEMPERATURE = temperatures.slice(-1)[0];
      WAVELENGTH = wavelengths.slice(-1)[0];
      HOVERWIEN = false;
      color = d3.scale.category20b();
      temperatureColor = function(d) {
        return color(d.temperature);
      };
      references = temperatures.map(makeSeries);
      seriesPath = d3.svg.line().x(function(d) {
        return xScale(d[0]);
      }).y(function(d) {
        return yScale(d[1]);
      });
      sliderScale = d3.scale.log().domain(d3.extent(temperatures));
      plotSeries = function(series) {
        return series.call(function(series) {
          return series.enter().append("g").classed({
            series: true
          }).append("path").style({
            stroke: temperatureColor
          });
        }).selectAll("path").data(function(d) {
          return [d.spectral_exitance];
        }).attr({
          d: seriesPath
        });
      };
      xScale = d3.scale.log().domain(xDomain);
      yScale = d3.scale.log().domain(yDomain);
      xAxis = d3.svg.axis().scale(xScale).orient('bottom');
      yAxis = d3.svg.axis().scale(yScale).orient('left');
      api = function(selection) {
        var clip, defs, el_xAxis, el_yAxis, explore, handleLabel, handleSolution, plotSvg, plots, plotsBg, render, resize, slide, slideHandle, slider, sliderLabel, sliderReferences, solutions, wavelengthLabel, wienSeries, xLabel, yLabel;
        selection.classed({
          planck: true
        });
        explore = function() {
          var mouseX, mouseY, val, _ref;
          _ref = d3.mouse(this), mouseX = _ref[0], mouseY = _ref[1];
          WAVELENGTH = xScale.invert(mouseX);
          val = parseInt(sliderScale.invert(mouseY));
          TEMPERATURE = Math.max(temperatures[0], Math.min(val, temperatures.slice(-1)[0]));
          return render();
        };
        render = function() {
          var series, solution, solutionObj, wavelengthSolutions;
          series = makeSeries(TEMPERATURE);
          solution = HOVERWIEN ? wiensLaw(TEMPERATURE) : plancksLaw(TEMPERATURE, WAVELENGTH);
          slideHandle.attr({
            transform: "translate(0, " + (sliderScale(TEMPERATURE)) + ")"
          });
          handleLabel.text(TEMPERATURE);
          handleSolution.text(solution[1] ? "I: " + (expwn(solution[1])) : "");
          plots.selectAll('.series.interactive').data([series]).call(plotSeries).classed({
            interactive: true
          }).select("path").style({
            color: "black"
          });
          wavelengthLabel.attr({
            transform: "translate(" + (xScale(WAVELENGTH)) + ", 20)"
          }).select("text").text("λ: " + (WAVELENGTH.toFixed(2)));
          solutions.selectAll('.solution.interactive').data([solution.solution]).call(function(solution) {
            return solution.enter().append("g").classed({
              solution: true,
              interactive: true
            }).append("circle").attr({
              r: 3
            });
          }).attr({
            transform: function(d) {
              return "translate(" + (xScale(solution[0])) + ", " + (yScale(solution[1])) + " )";
            }
          });
          wavelengthSolutions = references.map(function(d) {
            return {
              series: d,
              solution: HOVERWIEN ? wiensLaw(d.temperature) : plancksLaw(d.temperature, WAVELENGTH)
            };
          });
          solutionObj = wavelengthSolutions.reduce(function(memo, obj, i) {
            memo[obj.series.temperature] = obj.solution[1];
            return memo;
          }, {});
          sliderReferences.selectAll("text.solution").text(function(d) {
            return "" + (expwn(solutionObj[d.temperature]));
          });
          return solutions.selectAll(".solution.reference").data(wavelengthSolutions).call(function(solution) {
            return solution.enter().append("g").classed({
              solution: true,
              reference: true
            }).call(function(solution) {
              return solution.append("circle").attr({
                r: 5
              }).style({
                stroke: function(d) {
                  return temperatureColor(d.series);
                }
              });
            });
          }).attr({
            transform: function(d) {
              return "translate(" + (xScale(d.solution[0])) + ", " + (yScale(d.solution[1])) + " )";
            }
          });
        };
        resize = api.resize = function() {
          var HEIGHT, WIDTH, el_references;
          WIDTH = selection.node().clientWidth;
          HEIGHT = selection.node().clientHeight;
          xScale.range([padding.left, WIDTH - padding.right - sidebarWidth]);
          yScale.range([HEIGHT - padding.bottom, padding.top]);
          plotSvg.attr({
            width: WIDTH,
            height: HEIGHT
          });
          plotsBg.attr({
            width: WIDTH - padding.right - sidebarWidth,
            height: HEIGHT
          });
          clip.attr({
            width: xScale.range().slice(-1),
            height: yScale.range()[0],
            x: padding.left
          });
          el_xAxis.attr({
            transform: "translate(0, " + (HEIGHT - padding.bottom) + ")"
          }).call(xAxis).selectAll("text").text(function() {
            if (!!this.textContent) {
              return parseFloat(this.textContent);
            }
          });
          el_yAxis.attr({
            transform: "translate(" + padding.left + ", 0)"
          }).call(yAxis).selectAll("text").text(function() {
            return expwn(this.textContent);
          });
          yLabel.attr({
            transform: "translate(10, " + (HEIGHT / 2) + ") rotate(-90)"
          });
          xLabel.attr({
            transform: "translate(" + [WIDTH / 2, HEIGHT - 50] + ")"
          });
          el_references = plots.selectAll('.series').data(references).call(plotSeries);
          sliderScale.range([HEIGHT - sliderPadding.bottom, sliderPadding.top]);
          slider.attr({
            transform: "translate(" + (xScale.range()[1] + 20) + ", 0)"
          });
          sliderLabel.attr({
            transform: "translate(" + sidebarWidth + ", " + (HEIGHT / 2) + ") rotate(90)"
          });
          sliderReferences.attr({
            transform: function(d) {
              return "translate(0, " + (sliderScale(d.temperature)) + ")";
            }
          });
          wienSeries.selectAll("path").data([wiens]).attr({
            d: seriesPath
          });
          return render();
        };
        plotSvg = selection.selectAll(".plot.planck").data([1]).call(function(plotSvg) {
          plotSvg = plotSvg.enter().append("svg").classed({
            plot: true
          });
          plotSvg.append("defs").append("clipPath").classed({
            "planck-path": true
          }).attr({
            id: "planckPath"
          }).append("rect");
          plotSvg.append("g").classed({
            plots: true
          }).attr({
            "clip-path": "url(#planckPath)"
          }).call(function(plots) {
            plots.append("rect").classed({
              bg: true
            }).on({
              mousemove: explore
            });
            plots.append("g").classed({
              solutions: true
            });
            return plots.append("g").classed({
              wien: true
            }).on({
              mouseover: function() {
                HOVERWIEN = true;
                return render();
              },
              mouseout: function() {
                HOVERWIEN = false;
                return render();
              }
            }).append("path");
          });
          plotSvg.append("g").classed({
            axis: true,
            x: true
          });
          plotSvg.append("g").classed({
            axis: true,
            y: true
          });
          plotSvg.append("g").classed({
            label: true,
            y: true
          }).append("text").attr({
            "text-anchor": "middle",
            dy: ".71em"
          }).call(function(yLabel) {
            yLabel.append("tspan").text("Spectral Exitance");
            yLabel.append("tspan").classed({
              unit: true
            }).text(" [W/m²-µm]");
            return yLabel.append("tspan").classed({
              variable: true
            }).text(" I(λ,T)");
          });
          plotSvg.append("g").classed({
            label: true,
            x: true
          }).append("text").attr({
            "text-anchor": "middle",
            dy: ".71em",
            y: -10
          }).call(function(xLabel) {
            xLabel.append("tspan").text("Wavelength");
            xLabel.append("tspan").classed({
              unit: true
            }).text(" [µm]");
            return xLabel.append("tspan").classed({
              variable: true
            }).text(" λ");
          });
          return plotSvg.append("g").classed({
            wavelength: true,
            interactive: true
          }).attr({
            "text-anchor": "middle"
          }).append("text");
        });
        plots = plotSvg.select(".plots");
        solutions = plots.select(".solutions");
        plotsBg = plots.select(".bg");
        defs = plotSvg.select("defs");
        clip = defs.select(".planck-path rect");
        el_xAxis = plotSvg.select(".axis.x");
        el_yAxis = plotSvg.select(".axis.y");
        yLabel = plotSvg.select(".label.y text");
        xLabel = plotSvg.select(".label.x text");
        wavelengthLabel = plotSvg.select(".wavelength.interactive");
        wienSeries = plots.select(".wien");
        slide = d3.behavior.drag().on("drag", function(value) {
          var val;
          val = parseInt(sliderScale.invert(d3.event.y));
          TEMPERATURE = Math.max(temperatures[0], Math.min(val, temperatures.slice(-1)[0]));
          return render();
        });
        slider = plotSvg.selectAll(".slider").data([1]).call(function(slider) {
          slider = slider.enter().append("g").classed({
            slider: true
          });
          slider.append("text").classed({
            label: true
          }).attr({
            "text-anchor": "middle"
          }).call(function(sliderLabel) {
            sliderLabel.append("tspan").text("Temperature");
            sliderLabel.append("tspan").text(" [K]").classed({
              unit: true
            });
            return sliderLabel.append("tspan").text(" T").classed({
              variable: true
            });
          });
          slider.selectAll(".reference").data(references).call(function(init) {
            init = init.enter().append("g").classed({
              reference: true
            });
            init.append("circle").attr(sliderCircle).style({
              fill: temperatureColor
            });
            init.append("text").classed({
              temperature: true
            }).text(function(d) {
              return d.temperature;
            }).attr({
              dy: ".35em",
              "text-anchor": "end",
              x: sliderPadding.temperature
            }).style({
              fill: temperatureColor
            });
            return init.append("text").classed({
              solution: true
            }).attr({
              x: sliderPadding.solution,
              dy: ".35em",
              "text-anchor": "end"
            }).style({
              fill: temperatureColor
            });
          });
          return slider.append("g").classed({
            handle: true
          }).call(function(slideHandle) {
            slideHandle.call(slide);
            slideHandle.append("circle").attr(sliderCircle);
            return "slideHandle.append \"text\"\n  .classed temperature: true\n  .attr dy: \".35em\", x: sliderCircle.cx, \"text-anchor\": \"middle\"\nslideHandle.append \"text\"\n  .classed solution: true\n  .attr \"text-anchor\": \"end\", dy: \".35em\", dx: -5";
          });
        });
        sliderReferences = slider.selectAll(".reference");
        slideHandle = slider.select(".handle");
        sliderLabel = slider.select("text");
        handleLabel = slideHandle.select("text.temperature");
        handleSolution = slideHandle.select("text.solution");
        d3.select(window).on({
          "resize.planck": resize
        });
        return resize();
      };
      return api;
    };
    return Planck;
  });

}).call(this);
